# censor_audio.py

import pandas as pd
import argparse
import subprocess
from pathlib import Path
from rich.console import Console

# Setup rich console for pretty printing
console = Console()

def censor_with_ffmpeg(audio_path: Path, review_csv_path: Path, output_audio_path: Path):
    """
    Censors an audio file using FFmpeg, which can handle large files.

    Args:
        audio_path (Path): Path to the original audio file.
        review_csv_path (Path): Path to the CSV file with timestamps to censor.
        output_audio_path (Path): Path to save the censored audio file.
    """
    # --- Load Review File ---
    console.print(f"Loading review file from [green]{review_csv_path}[/green]...")
    try:
        timestamps_df = pd.read_csv(review_csv_path)
    except FileNotFoundError:
        console.print(f"[bold red]Error: Review file not found at '{review_csv_path}'[/bold red]")
        return
        
    if timestamps_df.empty:
        console.print("[bold yellow]Review file is empty. No censoring will be applied.[/bold yellow]")
        console.print("No output file will be created.")
        return

    # --- Construct the FFmpeg Filter ---
    console.print(f"Building FFmpeg filter for [yellow]{len(timestamps_df)}[/yellow] sections...")
    filter_parts = []
    for _, row in timestamps_df.iterrows():
        start_sec = row['start']
        end_sec = row['end']
        filter_parts.append(f"volume=enable='between(t,{start_sec},{end_sec})':volume=0")
    
    audio_filter_string = ",".join(filter_parts)

    # --- Build and Run the FFmpeg Command ---
    command = [
        "ffmpeg",
        "-y",
        "-i", str(audio_path),
        "-map", "0:a",              # THIS IS THE FIX: Select only the audio stream
        "-af", audio_filter_string,
        "-c:a", "aac",
        "-b:a", "128k",
        str(output_audio_path)
    ]
    
    console.print("\n[bold cyan]Executing FFmpeg...[/bold cyan]")
    console.print("This may take a long time for large files. FFmpeg will print its own progress below.")
    # console.print(f"Command: {' '.join(command)}") # Uncomment for debugging

    try:
        process = subprocess.run(
            command,
            check=True,
            capture_output=True,
            text=True
        )
    except subprocess.CalledProcessError as e:
        console.print("\n[bold red]--- FFmpeg Error ---[/bold red]")
        console.print("FFmpeg failed to process the file. Here is the error output:")
        console.print(f"[red]{e.stderr}[/red]")
        return
    except FileNotFoundError:
        console.print("\n[bold red]Error: 'ffmpeg' command not found.[/bold red]")
        console.print("Please ensure FFmpeg is installed and accessible on your system's PATH.")
        return

    console.print("\n[bold green]Success![/bold green] Censoring complete.")
    console.print(f"Output file saved to: [cyan]{output_audio_path}[/cyan]")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Censor a large audio file using FFmpeg.")
    parser.add_argument("audio_file", type=Path, help="Path to the original audio file to censor (e.g., input.mp3 or input.m4b).")
    parser.add_argument("review_csv", type=Path, help="Path to the review CSV file generated by the analysis script.")
    parser.add_argument("--output_file", type=Path, help="Path to save the new, censored audio file.")
    
    args = parser.parse_args()

    if args.output_file:
        output_file = args.output_file
    else:
        p = args.audio_file
        output_file = p.parent / f"{p.stem}_censored{p.suffix}"

    if not args.audio_file.exists():
        console.print(f"[bold red]Error: Audio file not found at '{args.audio_file}'[/bold red]")
    else:
        censor_with_ffmpeg(args.audio_file, args.review_csv, output_file)