# censor_audio.py

import pandas as pd
import argparse
from pathlib import Path
from pydub import AudioSegment
from rich.console import Console
from rich.progress import track

# Setup rich console for pretty printing
console = Console()

def censor(audio_path: Path, review_csv_path: Path, output_audio_path: Path):
    """
    Censors an audio file based on a timestamp review file by rebuilding the audio.

    Args:
        audio_path (Path): Path to the original audio file.
        review_csv_path (Path): Path to the CSV file with timestamps to censor.
        output_audio_path (Path): Path to save the censored audio file.
    """
    # --- Load Audio and Review File ---
    console.print(f"Loading original audio from [green]{audio_path}[/green]...")
    file_extension = audio_path.suffix.lower()

    try:
        if file_extension == ".m4b":
            # THIS IS THE FIX: Use FFmpeg's 'mp4' demuxer for M4B files
            audio = AudioSegment.from_file(audio_path, format="mp4")
        else:
            audio = AudioSegment.from_file(audio_path)
    except Exception as e:
        console.print(f"[bold red]Error loading audio file: {e}[/bold red]")
        return

    console.print(f"Loading review file from [green]{review_csv_path}[/green]...")
    try:
        timestamps_df = pd.read_csv(review_csv_path).sort_values(by='start').reset_index(drop=True)
    except FileNotFoundError:
        console.print(f"[bold red]Error: Review file not found at '{review_csv_path}'[/bold red]")
        return
        
    if timestamps_df.empty:
        console.print("[bold yellow]Review file is empty. No censoring will be applied.[/bold yellow]")
        original_audio.export(output_audio_path, format=output_audio_path.suffix[1:])
        return

    # --- Rebuild Audio with Censorship ---
    console.print(f"Rebuilding audio with [yellow]{len(timestamps_df)}[/yellow] censored sections...")
    
    final_audio = AudioSegment.silent(duration=0)
    last_end_ms = 0

    for _, row in track(timestamps_df.iterrows(), description="Processing sections..."):
        start_ms = int(row['start'] * 1000)
        end_ms = int(row['end'] * 1000)

        # Append the clean segment before the censored word
        if start_ms > last_end_ms:
            final_audio += original_audio[last_end_ms:start_ms]

        # Append a silent segment for the duration of the censored word
        duration = end_ms - start_ms
        if duration > 0:
            final_audio += AudioSegment.silent(duration=duration)
        
        last_end_ms = end_ms

    # Append the remaining part of the audio after the last censored word
    if len(original_audio) > last_end_ms:
        final_audio += original_audio[last_end_ms:]

    # --- Export Final Audio ---
    console.print(f"Exporting censored audio to [green]{output_audio_path}[/green]...")
    try:
        final_audio.export(output_audio_path, format=output_audio_path.suffix[1:])
    except Exception as e:
        console.print(f"[bold red]Error exporting audio file: {e}[/bold red]")
        return

    console.print("\n[bold green]Success![/bold green] Censoring complete.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Censor an audio file using a timestamp review file.")
    parser.add_argument("audio_file", type=Path, help="Path to the original audio file to censor (e.g., input.mp3 or input.m4b).")
    parser.add_argument("review_csv", type=Path, help="Path to the review CSV file generated by the analysis script.")
    parser.add_argument("--output_file", type=Path, help="Path to save the new, censored audio file.")
    
    args = parser.parse_args()

    if args.output_file:
        output_file = args.output_file
    else:
        p = args.audio_file
        output_file = p.parent / f"{p.stem}_censored{p.suffix}"

    if not args.audio_file.exists():
        console.print(f"[bold red]Error: Audio file not found at '{args.audio_file}'[/bold red]")
    else:
        censor(args.audio_file, args.review_csv, output_file)